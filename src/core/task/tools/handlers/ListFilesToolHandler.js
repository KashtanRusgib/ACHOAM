import path from "node:path";
import { formatResponse } from "@core/prompts/responses";
import { getWorkspaceBasename, resolveWorkspacePath } from "@core/workspace";
import { listFiles } from "@services/glob/list-files";
import { arePathsEqual, getReadablePath, isLocatedInWorkspace } from "@utils/path";
import { telemetryService } from "@/services/telemetry";
import { ClineDefaultTool } from "@/shared/tools";
import { showNotificationForApproval } from "../../utils";
import { ToolResultUtils } from "../utils/ToolResultUtils";
export class ListFilesToolHandler {
    validator;
    name = ClineDefaultTool.LIST_FILES;
    constructor(validator) {
        this.validator = validator;
    }
    getDescription(block) {
        return `[${block.name} for '${block.params.path}']`;
    }
    async handlePartialBlock(block, uiHelpers) {
        const relPath = block.params.path;
        // Get config access for services
        const config = uiHelpers.getConfig();
        // Create and show partial UI message
        const recursiveRaw = block.params.recursive;
        const recursive = recursiveRaw?.toLowerCase() === "true";
        const sharedMessageProps = {
            tool: recursive ? "listFilesRecursive" : "listFilesTopLevel",
            path: getReadablePath(config.cwd, uiHelpers.removeClosingTag(block, "path", relPath)),
            content: "",
            operationIsLocatedInWorkspace: await isLocatedInWorkspace(relPath),
        };
        const partialMessage = JSON.stringify(sharedMessageProps);
        // Handle auto-approval vs manual approval for partial
        if (await uiHelpers.shouldAutoApproveToolWithPath(block.name, relPath)) {
            await uiHelpers.removeLastPartialMessageIfExistsWithType("ask", "tool");
            await uiHelpers.say("tool", partialMessage, undefined, undefined, block.partial);
        }
        else {
            await uiHelpers.removeLastPartialMessageIfExistsWithType("say", "tool");
            await uiHelpers.ask("tool", partialMessage, block.partial).catch(() => { });
        }
    }
    async execute(config, block) {
        const relDirPath = block.params.path;
        const recursiveRaw = block.params.recursive;
        const recursive = recursiveRaw?.toLowerCase() === "true";
        // Extract provider using the proven pattern from ReportBugHandler
        const apiConfig = config.services.stateManager.getApiConfiguration();
        const currentMode = config.services.stateManager.getGlobalSettingsKey("mode");
        const provider = (currentMode === "plan" ? apiConfig.planModeApiProvider : apiConfig.actModeApiProvider);
        // Validate required parameters
        const pathValidation = this.validator.assertRequiredParams(block, "path");
        if (!pathValidation.ok) {
            config.taskState.consecutiveMistakeCount++;
            return await config.callbacks.sayAndCreateMissingParamError(this.name, "path");
        }
        config.taskState.consecutiveMistakeCount = 0;
        // Resolve the absolute path based on multi-workspace configuration
        const pathResult = resolveWorkspacePath(config, relDirPath, "ListFilesToolHandler.execute");
        const { absolutePath, displayPath } = typeof pathResult === "string" ? { absolutePath: pathResult, displayPath: relDirPath } : pathResult;
        // Determine workspace context for telemetry
        const fallbackAbsolutePath = path.resolve(config.cwd, relDirPath ?? "");
        const workspaceContext = {
            isMultiRootEnabled: config.isMultiRootEnabled || false,
            usedWorkspaceHint: typeof pathResult !== "string", // multi-root path result indicates hint usage
            resolvedToNonPrimary: !arePathsEqual(absolutePath, fallbackAbsolutePath),
            resolutionMethod: (typeof pathResult !== "string" ? "hint" : "primary_fallback"),
        };
        // Check clineignore access
        const accessValidation = this.validator.checkClineIgnorePath(relDirPath);
        if (!accessValidation.ok) {
            await config.callbacks.say("clineignore_error", relDirPath);
            return formatResponse.toolError(formatResponse.clineIgnoreError(relDirPath));
        }
        // Execute the actual list files operation
        const [files, didHitLimit] = await listFiles(absolutePath, recursive, 200);
        const result = formatResponse.formatFilesList(absolutePath, files, didHitLimit, config.services.clineIgnoreController);
        // Handle approval flow
        const sharedMessageProps = {
            tool: recursive ? "listFilesRecursive" : "listFilesTopLevel",
            path: getReadablePath(config.cwd, displayPath),
            content: result,
            operationIsLocatedInWorkspace: await isLocatedInWorkspace(relDirPath),
        };
        const completeMessage = JSON.stringify(sharedMessageProps);
        if (await config.callbacks.shouldAutoApproveToolWithPath(block.name, relDirPath)) {
            // Auto-approval flow
            await config.callbacks.removeLastPartialMessageIfExistsWithType("ask", "tool");
            await config.callbacks.say("tool", completeMessage, undefined, undefined, false);
            // Capture telemetry
            telemetryService.captureToolUsage(config.ulid, block.name, config.api.getModel().id, provider, true, true, workspaceContext, block.isNativeToolCall);
        }
        else {
            // Manual approval flow
            const notificationMessage = `Cline wants to view directory ${getWorkspaceBasename(absolutePath, "ListFilesToolHandler.notification")}/`;
            // Show notification
            showNotificationForApproval(notificationMessage, config.autoApprovalSettings.enableNotifications);
            await config.callbacks.removeLastPartialMessageIfExistsWithType("say", "tool");
            const didApprove = await ToolResultUtils.askApprovalAndPushFeedback("tool", completeMessage, config);
            if (!didApprove) {
                telemetryService.captureToolUsage(config.ulid, block.name, config.api.getModel().id, provider, false, false, workspaceContext, block.isNativeToolCall);
                return formatResponse.toolDenied();
            }
            else {
                telemetryService.captureToolUsage(config.ulid, block.name, config.api.getModel().id, provider, false, true, workspaceContext, block.isNativeToolCall);
            }
        }
        // Run PreToolUse hook after approval but before execution
        try {
            const { ToolHookUtils } = await import("../utils/ToolHookUtils");
            await ToolHookUtils.runPreToolUseIfEnabled(config, block);
        }
        catch (error) {
            const { PreToolUseHookCancellationError } = await import("@core/hooks/PreToolUseHookCancellationError");
            if (error instanceof PreToolUseHookCancellationError) {
                return formatResponse.toolDenied();
            }
            throw error;
        }
        return result;
    }
}
//# sourceMappingURL=ListFilesToolHandler.js.map